<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCGONEXT - AI Bridge Console</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background: #ffffff;
            color: #000000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: #ffffff;
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000000;
            flex-shrink: 0;
        }
        .header h1 {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.25rem;
            color: #000000;
            font-weight: 700;
            letter-spacing: 0.05em;
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .nav-links {
            display: flex;
            gap: 0.5rem;
        }
        .nav-link {
            font-family: 'Courier New', Courier, monospace;
            color: #000000;
            text-decoration: none;
            padding: 0.4rem 0.8rem;
            border: 1px solid transparent;
            font-size: 0.85rem;
            transition: all 0.2s;
            letter-spacing: 0.03em;
        }
        .nav-link:hover {
            border-bottom: 1px solid #000000;
        }
        .nav-link.active {
            border-bottom: 2px solid #000000;
            font-weight: 500;
        }
        .status-badge {
            font-family: 'Courier New', Courier, monospace;
            background: #ffffff;
            border: 1px solid #000000;
            padding: 0.4rem 0.8rem;
            border-radius: 0;
            font-size: 0.85rem;
            color: #000000;
            letter-spacing: 0.03em;
        }

        /* Grid mode (overview) */
        .container-grid {
            flex: 1;
            padding: 1rem;
            display: grid;
            gap: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            align-content: center;
        }
        /* Dynamic grid layout based on agent count */
        .container-grid[data-agent-count="1"] {
            grid-template-columns: 1fr;
        }
        .container-grid[data-agent-count="2"] {
            grid-template-columns: repeat(2, 1fr);
        }
        .container-grid[data-agent-count="3"] {
            grid-template-columns: repeat(3, 1fr);
        }
        .container-grid[data-agent-count="4"] {
            grid-template-columns: repeat(2, 1fr);
        }
        .container-grid[data-agent-count="5"],
        .container-grid[data-agent-count="6"] {
            grid-template-columns: repeat(3, 1fr);
        }
        /* 7+ agents: use auto-fit for flexibility */
        .container-grid:not([data-agent-count="1"]):not([data-agent-count="2"]):not([data-agent-count="3"]):not([data-agent-count="4"]):not([data-agent-count="5"]):not([data-agent-count="6"]) {
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        }
        .agent-panel {
            background: #ffffff;
            border-radius: 0;
            overflow: hidden;
            border: 1px solid #000000;
            display: flex;
            flex-direction: column;
        }
        .agent-header {
            padding: 0.5rem 1rem;
            background: #ffffff;
            border-bottom: 1px solid #000000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .agent-name {
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            letter-spacing: 0.03em;
        }
        .agent-icon {
            font-size: 1.1rem;
        }
        .agent-status {
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            letter-spacing: 0.03em;
        }
        .restart-btn {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }
        .restart-btn:hover {
            background: #000;
            color: #fff;
        }
        .restart-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #cccccc;
        }
        .status-dot.running { background: #22c55e; }
        .status-dot.stopped { background: #cccccc; }
        .status-dot.busy { background: #eab308; }
        .status-dot.error { background: #ef4444; }
        .input-badge {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border: 1px solid;
            margin-left: 0.5rem;
        }
        .input-badge.enabled {
            color: #22c55e;
            border-color: #22c55e;
        }
        .input-badge.disabled {
            color: #888;
            border-color: #888;
        }
        .terminal-container {
            flex: 1;
            min-height: 250px;
            padding: 0.25rem;
            background: #1a1a2e;
        }

        /* Agent image for overview mode */
        .agent-image {
            aspect-ratio: 4 / 3;
            background: #1a1a2e;
            cursor: pointer;
            transition: opacity 0.2s;
            overflow: hidden;
            position: relative;
        }
        .agent-image:hover {
            opacity: 0.85;
        }
        .agent-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .agent-image .click-hint {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            font-size: 0.7rem;
            color: #888;
        }

        /* Fullscreen mode (single agent) */
        .container-full {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.5rem;
        }
        .container-full .agent-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .container-full .terminal-container {
            flex: 1;
            min-height: 0;
        }

        .hidden { display: none !important; }

        @media (max-width: 900px) {
            .container-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>CCGONEXT - AI Bridge Console</h1>
        <div class="header-right">
            <nav class="nav-links">
                <a href="/" class="nav-link" data-nav="overview">Overview</a>
                <!-- Agent links will be dynamically generated -->
            </nav>
            <span class="input-badge disabled" id="input-badge">READ-ONLY</span>
            <div class="status-badge" id="global-status">Connecting...</div>
        </div>
    </header>

    <!-- Overview mode: 2x2 grid -->
    <div class="container-grid" id="overview-container">
        <!-- Agent panels will be dynamically generated -->
    </div>

    <!-- Fullscreen mode: single agent -->
    <div class="container-full hidden" id="fullscreen-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        // Centralized agent configuration - single source of truth
        const AGENTS = [
            { id: 'codex',      label: 'Codex',      icon: 'ðŸ¤–', image: 'codexcli.jpg' },
            { id: 'gemini',     label: 'Gemini',     icon: 'ðŸ’Ž', image: 'geminicli.jpg' },
            { id: 'opencode',   label: 'OpenCode',   icon: 'ðŸ”·', image: 'opencode.jpg' },
            { id: 'claudecode', label: 'ClaudeCode', icon: 'ðŸŽ¯', image: 'claudecode.jpg' }
        ];

        // Create a lookup map for efficient access
        const agentById = Object.fromEntries(AGENTS.map(a => [a.id, a]));

        // Will be populated from server
        let enabledAgents = [];

        const terminals = {};
        const websockets = {};

        // Determine current mode from URL
        const path = window.location.pathname.replace(/^\//, '').toLowerCase();
        const singleAgent = path && agentById[path] ? path : null;

         function initTerminal(agent, container) {
             const term = new Terminal({
                 theme: {
                     background: '#1a1a2e',
                     foreground: '#eee',
                     cursor: '#e94560'
                 },
                 fontSize: 14,
                 fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                 cursorBlink: inputEnabled,
                 disableStdin: !inputEnabled,
                 allowProposedApi: true
             });
 
             const fitAddon = new FitAddon.FitAddon();
             term.loadAddon(fitAddon);
             term.open(container);
 
             // Make keyboard input work: ensure xterm gets focus when the user clicks the terminal.
             container.addEventListener('mousedown', () => term.focus());
             container.addEventListener('touchstart', () => term.focus(), { passive: true });
             container.addEventListener('focus', () => term.focus());
 
             // In fullscreen (single-agent) mode, focus immediately for "type to interact".
             if (singleAgent) {
                 requestAnimationFrame(() => term.focus());
             }
 
             // Delay fit to ensure container has size
             requestAnimationFrame(() => {
                 fitAddon.fit();
                 sendResize(agent, term.cols, term.rows);
            });

            terminals[agent] = { term, fitAddon };

             // Handle keyboard input
             term.onData(data => {
                 if (!inputEnabled) return;
                 if (websockets[agent] && websockets[agent].readyState === WebSocket.OPEN) {
                     websockets[agent].send(data);
                 }
             });
 
             // Handle binary input (for mouse events, etc.)
             term.onBinary(data => {
                 if (!inputEnabled) return;
                 if (websockets[agent] && websockets[agent].readyState === WebSocket.OPEN) {
                     const bytes = new Uint8Array(data.length);
                     for (let i = 0; i < data.length; i++) {
                         bytes[i] = data.charCodeAt(i);
                    }
                    websockets[agent].send(bytes);
                }
            });

            return { term, fitAddon };
        }

        // Send resize command to backend
        function sendResize(agent, cols, rows) {
            if (websockets[agent] && websockets[agent].readyState === WebSocket.OPEN) {
                const cmd = '\x00' + JSON.stringify({ type: 'resize', cols, rows });
                websockets[agent].send(cmd);
            }
        }

        function connectWebSocket(agent) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(`${protocol}//${window.location.host}/ws/${agent}`);

            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                console.log(`WebSocket connected for ${agent}`);
                // Send initial resize after connection
                if (terminals[agent]) {
                    const { term } = terminals[agent];
                    sendResize(agent, term.cols, term.rows);
                }
            };

            ws.onmessage = (event) => {
                if (terminals[agent]) {
                    const data = event.data instanceof ArrayBuffer
                        ? new TextDecoder().decode(event.data)
                        : event.data;
                    terminals[agent].term.write(data);
                }
            };

            ws.onclose = () => {
                console.log(`WebSocket closed for ${agent}`);
                setTimeout(() => connectWebSocket(agent), 3000);
            };

            ws.onerror = (err) => {
                console.error(`WebSocket error for ${agent}:`, err);
            };

            websockets[agent] = ws;
        }

        let inputEnabled = false;

        async function fetchStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();

                // Update enabled agents list from server
                const serverAgents = data.agents.map(a => a.name);
                if (enabledAgents.length === 0) {
                    // First fetch - initialize enabled agents
                    enabledAgents = serverAgents;
                }

                // Update input enabled status
                inputEnabled = data.input_enabled || false;
                updateInputBadge();

                let onlineCount = 0;
                data.agents.forEach(agent => {
                    updateAgentStatus(agent.name, agent.state);
                    if (agent.state !== 'STOPPED' && agent.state !== 'DEAD') {
                        onlineCount++;
                    }
                });

                document.getElementById('global-status').textContent = `${onlineCount} Online`;
                return data.agents;
            } catch (err) {
                console.error('Failed to fetch status:', err);
                document.getElementById('global-status').textContent = 'Disconnected';
                return [];
            }
        }

         function updateInputBadge() {
             const badge = document.getElementById('input-badge');
             if (badge) {
                 badge.textContent = inputEnabled ? 'INPUT' : 'READ-ONLY';
                 badge.className = 'input-badge ' + (inputEnabled ? 'enabled' : 'disabled');
             }
 
             // Keep terminal input state in sync with backend config.
             Object.values(terminals).forEach(({ term }) => {
                 term.options.disableStdin = !inputEnabled;
                 term.options.cursorBlink = inputEnabled;
             });
         }

        function updateAgentStatus(agent, state) {
            const dot = document.getElementById(`${agent}-status-dot`);
            const text = document.getElementById(`${agent}-status-text`);

            if (!dot || !text) return;

            text.textContent = state;
            dot.className = 'status-dot';

            switch (state) {
                case 'IDLE':
                case 'READY_TIMEOUT':
                    dot.classList.add('running');
                    break;
                case 'BUSY':
                case 'STARTING':
                    dot.classList.add('busy');
                    break;
                case 'STUCK':
                case 'DEAD':
                    dot.classList.add('error');
                    break;
                default:
                    dot.classList.add('stopped');
            }
        }

        async function restartAgent(agent) {
            const agentData = agentById[agent];
            const label = agentData ? agentData.label : agent;
            if (!confirm(`Restart ${label}?`)) {
                return;
            }
            const btn = document.getElementById(`${agent}-restart-btn`);
            if (btn) {
                btn.disabled = true;
                btn.textContent = '...';
            }
            try {
                const res = await fetch(`/api/restart/${agent}`, { method: 'POST' });
                const data = await res.json();
                if (!data.success) {
                    console.error(`Failed to restart ${agent}: ${data.message}`);
                }
            } catch (err) {
                console.error(`Failed to restart ${agent}:`, err);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Restart';
                }
                fetchStatus();
            }
        }

         function createAgentPanel(agent, isFullscreen = false) {
             const agentData = agentById[agent];
             if (!agentData) return null;

             const panel = document.createElement('div');
             panel.className = 'agent-panel';
             panel.dataset.agent = agent;

             const terminalContent = isFullscreen
                 ? `<div class="terminal-container" id="${agent}-terminal" tabindex="0"></div>`
                 : `<div class="agent-image" onclick="window.location.href='/${agent}'">
                     <img src="/${agentData.image}" alt="${agentData.label}">
                     <div class="click-hint">Click to open</div>
                   </div>`;

             panel.innerHTML = `
                 <div class="agent-header">
                     <div class="agent-name">
                         <span class="agent-icon" aria-hidden="true">${agentData.icon}</span>
                         <span>${agentData.label}</span>
                     </div>
                     <div class="agent-status">
                         <button class="restart-btn" id="${agent}-restart-btn" onclick="restartAgent('${agent}')">Restart</button>
                         <span class="status-dot" id="${agent}-status-dot"></span>
                         <span id="${agent}-status-text">STOPPED</span>
                     </div>
                 </div>
                 ${terminalContent}
             `;
             return panel;
         }

        function setupFullscreenMode(agent) {
            document.getElementById('overview-container').classList.add('hidden');
            const fullContainer = document.getElementById('fullscreen-container');
            fullContainer.classList.remove('hidden');

            const panel = createAgentPanel(agent, true);
            if (panel) {
                fullContainer.innerHTML = '';
                fullContainer.appendChild(panel);
            }

            const agentData = agentById[agent];
            document.title = `CCGONEXT - ${agentData ? agentData.label : 'Agent'}`;
        }

        function updateNavLinks() {
            document.querySelectorAll('.nav-link').forEach(link => {
                const nav = link.dataset.nav;
                if ((nav === 'overview' && !singleAgent) || nav === singleAgent) {
                    link.classList.add('active');
                }
            });
        }

        // Initialize
        async function init() {
            // Fetch enabled agents from server first
            const agents = await fetchStatus();
            if (agents.length === 0) {
                // Fallback to all agents if fetch failed
                enabledAgents = AGENTS.map(a => a.id);
            }

            // Dynamically generate navigation links (only for enabled agents)
            const navContainer = document.querySelector('.nav-links');
            if (navContainer) {
                enabledAgents.forEach(agentId => {
                    const agentData = agentById[agentId];
                    if (!agentData) return;

                    const navLink = document.createElement('a');
                    navLink.href = `/${agentData.id}`;
                    navLink.className = 'nav-link';
                    navLink.dataset.nav = agentData.id;
                    navLink.textContent = agentData.label;
                    navContainer.appendChild(navLink);
                });
            }

            // Dynamically generate agent panels for overview mode (only enabled agents)
            const overviewContainer = document.getElementById('overview-container');
            if (overviewContainer && !singleAgent) {
                // Set grid layout based on agent count
                overviewContainer.setAttribute('data-agent-count', enabledAgents.length);

                enabledAgents.forEach(agentId => {
                    const agentData = agentById[agentId];
                    if (!agentData) return;

                    const panel = createAgentPanel(agentData.id);
                    if (panel) {
                        overviewContainer.appendChild(panel);
                    }
                });
            }

            updateNavLinks();

            if (singleAgent) {
                setupFullscreenMode(singleAgent);
                // Only initialize terminal and WebSocket in fullscreen mode
                const container = document.getElementById(`${singleAgent}-terminal`);
                if (container) {
                    initTerminal(singleAgent, container);
                    connectWebSocket(singleAgent);
                }
            }

            // Handle resize (only needed in fullscreen mode)
            window.addEventListener('resize', () => {
                Object.entries(terminals).forEach(([agent, { term, fitAddon }]) => {
                    fitAddon.fit();
                    sendResize(agent, term.cols, term.rows);
                });
            });

            // Status already fetched, just set interval for updates
            setInterval(fetchStatus, 5000);
        }

        init();
    </script>
</body>
</html>
